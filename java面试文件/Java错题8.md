# 2018-8-9

---

**1.定义有StringBuffer s1=new StringBuffer\(10\);s1.append\(“1234”\)则s1.length\(\)和s1.capacity\(\)分别是多少?**

【**解析**】：length表示的是当前字符串长度

如果字符串长度没有初始化长度大，capacity返回初始化的长度

如果append后的字符串长度超过初始化长度，capacity返回增长后的长度

**2.下列关于构造方法不正确的是：（D）**

* **类的构造方法和类同名**
* **一个类可以有多个构造方法**
* **在实例化对象时必须调用类的构造方法**
* **构造方法可以和该类其他方法一样被该类对象调用**

【**解析**】：

1.构造方法也是类的方法，可以在创建对象时为成员变量赋值

2.构造方法可以进行重载，但是参数列表必须不相同，不以返回值和访问级别进行区分

3.构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型。

4.构造方法一定要与定义为public的类同名

5.构造方法不能被对象调用，只会创建对象，使用new关键字

**3.关于sleep和wait,以下描述错误的是**

* **sleep是线程类的方法，wait是object的方法**
* **sleep不释放对象锁，wait放弃对象锁**
* **sleep暂停线程，但监控状态依然保持，结束后会自动恢复**
* **wait进入等待锁定池，只有针对此对象发出notify方法获得对象锁进入运行状态**

【**解析**】：首先，sleep\(\)是Thread类中的方法，而wait\(\)则是Object类中的方法。

sleep\(\)方法导致了程序暂停，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep\(\)方法的过程中，线程不会释放对象锁。

wait\(\)方法会导致线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify\(\)方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。

注意是准备获取对象锁进入运行状态，而不是立即获得

**4.Java关键字的组成**

【**解析**】：Java标识符由数字，汉字，字母和下划线（\_），美元符号（$）或人民币符号（￥）组成。在Java中是区分大小写的，而且还要求首位不能是数字。最重要的是，Java关键字不能当作Java标识符。

**5.字符流和字节流的父类**

【**解析**】：

![](/assets/字符流和字节流.png)

**6.下列关于java并发的说法中正确的是：**

* **copyonwritearraylist适用于写多读少的并发场景**
* **readwritelock适用于读多写少的并发场景**
* **concurrenthashmap的写操作不需要加锁，读操作需要加锁**
* **只要在定义int类型的成员变量i的时候加上volatile关键字，那么多线程并发执行i++这样的操作的时候就是线程安全的了**

【**解析**】：

CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。

ReadWriteLock 当写操作时，其他线程无法读取或写入数据，而当读操作时，其它线程无法写入数据，但却可以读取数据 。适用于 读取远远大于写入的操作。

ConcurrentHashMap是一个线程安全的Hash Table，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁。

**7.下面有关JVM内存，说法错误的是？（这个不该错的，看错了后面的线程隔离）**

* **程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的**
* **Java方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的**
* **方法区用于存储JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程隔离的**
* **原则上讲，所有的对象都在堆区上分配内存，是线程之间共享的**

【**解析**】：运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器

虚拟机栈区 ：也就是我们常说的栈区，线程私有，存放基本类型，对象的引用和 returnAddress ，在编译期间完成分配。

堆区 ， JAVA 堆，也称 GC 堆，所有线程共享，存放对象的实例和数组， JAVA 堆是垃圾收集器管理的主要区域。

方法区 ：所有线程共享，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。

程序计数器 ：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址。

**8.**

【**解析**】：

public Method\[\] getDeclaredMethods\(\)返回类或接口声明的所有方法，包括public, protected, default \(package\) 访问和private方法的Method对象，但不包括继承的方法。当然也包括它所实现接口的方法。

public Method\[\] getMethods\(\)返回类的所有public方法，包括其继承类的公用方法，当然也包括它所实现接口的方法。

**9.下面几个关于Java里queue的说法哪些是正确的（）？**

* **LinkedBlockingQueue是一个可选有界队列，不允许null值**
* **PriorityQueue，LinkedBlockingQueue都是线程不安全的**
* **PriorityQueue是一个无界队列，不允许null值，入队和出队的时间复杂度是O（log\(n\)）**
* **PriorityQueue，ConcurrentLinkedQueue都遵循FIFO原则**

【**解析**】：

1、LinkedBlockingQueue：基于链接节点的可选限定的blocking queue 。 这个队列排列元素FIFO（先进先出）。 队列的头部是队列中最长的元素。 队列的尾部是队列中最短时间的元素。 新元素插入队列的尾部，队列检索操作获取队列头部的元素。 链接队列通常具有比基于阵列的队列更高的吞吐量，但在大多数并发应用程序中的可预测性能较低。

blocking queue说明：不接受null元素；可能是容量有限的；实现被设计为主要用于生产者 - 消费者队列；不支持任何类型的“关闭”或“关闭”操作，表示不再添加项目实现是线程安全的；

2、PriorityQueue：

2.1、基于优先级堆的无限优先级queue 。 优先级队列的元素根据它们的有序natural ordering ，或由一个Comparator在队列构造的时候提供，这取决于所使用的构造方法。 优先队列不允许null元素。 依靠自然排序的优先级队列也不允许插入不可比较的对象（这样做可能导致ClassCastException ）。

2.2、该队列的头部是相对于指定顺序的最小元素。 如果多个元素被绑定到最小值，那么头就是这些元素之一 - 关系被任意破坏。 队列检索操作poll ， remove ， peek和element访问在队列的头部的元件。

2.3、优先级队列是无限制的，但是具有管理用于在队列上存储元素的数组的大小的内部容量 。 它始终至少与队列大小一样大。 当元素被添加到优先级队列中时，其容量会自动增长。 没有规定增长政策的细节。

2.4、该类及其迭代器实现Collection和Iterator接口的所有可选方法。 方法iterator\(\)中提供的迭代器不能保证以任何特定顺序遍历优先级队列的元素。 如果需要有序遍历，请考虑使用Arrays.sort\(pq.toArray\(\)\) 。

2.5、请注意，此实现不同步。 如果任何线程修改队列，多线程不应同时访问PriorityQueue实例。 而是使用线程安全的PriorityBlockingQueue类。

实现注意事项：此实现提供了O（log\(n\)）的时间入队和出队方法（ offer ， poll ， remove\(\)和add ）; remove\(Object\)和contains\(Object\)方法的线性时间; 和恒定时间检索方法（ peek ， element和size ）。

3、ConcurrentLinkedQueue：基于链接节点的无界并发deque\(deque是双端队列\) 。 并发插入，删除和访问操作可以跨多个线程安全执行。 A ConcurrentLinkedDeque是许多线程将共享对公共集合的访问的适当选择。像大多数其他并发集合实现一样，此类不允许使用null元素。

