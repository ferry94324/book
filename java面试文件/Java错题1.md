### 2018-4-3

---

1.设栈的存储空间为 S\(1:60\) ，初始状态为 top=61 。现经过一系列正常的入栈与退栈操作后， top=1 ，则栈中的元素个数为（ ）。

【解析】：栈是一种特殊的线性表，它所有的插入与删除都限定在表的同一端进行。入栈运算即在栈顶位置插入一个新元素，退栈运算即取出栈顶元素赋予指定变量。栈为空时，栈顶指针 top=0 ，经过入栈和退栈运算，指针始终指向栈顶元素。初始状态为 top=61 ，当 top=1 时，元素依次存储在单元 1 ： 60 中，个数为 60 

2.在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？

管道

消息队列

高速缓存数据库

套接字

【解析】：管道通信类似于通信中半双工信道的进程通信机制，一个管道可以实现双向的数据传输，而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行

3.关于AOP错误的是？

AOP将散落在系统中的“方面”代码集中实现

AOP有助于提高系统可维护性

AOP已经表现出将要替代面向对象的趋势

AOP是一种设计模式，Spring提供了一种实现

【解析】：AOP 和 OOP的区别：

1. 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。

2. 面向对象编程 \(oop\) 则是对业务分析中抽取的实体进行方法和属性的封装。

也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。

AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。

4.采用败者树进行K路平衡归并时,总的\(包括访外\)归并效率与K\(\)

【解析】：

![](/assets/败者树.png)

这里边logk\(m\)表示读取次数等于（log2\(m\)/log2\(k\)）,比较次数\(n-1\)，如果采用多路归并树的话比较次数log2\(k\)，恰好与分母约掉，这样归并的比较次数与k无关了

5.java 的字符类型采用的是 Unicode 编码方案，每个 Unicode 码占用（）个比特位。

【解析】：在java中一个unicode占2个字节（byte）。

一个字节等于8比特位（bit）。

所以每个Unicode码占用16个比特位。

注意：区分编码和编码格式编码： 

编码就是一个编号\(数字\)到字符的一种映射关系，就仅仅是一种一对一的映射而已，可以理解成一个很大的对应表格

java默认的字符集是Unicode（占两个字节byte，一个字节=8比特位bit，所以每个Unicode占用16比特位）

编码格式：编码格式 是用来序列化或存储编码中提到的那个“编号\(数字\)”的一种“格式”，包括gbk和utf-8

    gbk： 是指中国的中文字符，其它它包含了简体中文与繁体中文字符

    UTF-8： 它是一种全国家通过的一种编码

6.某二叉树结点的中序序列为A、B、C、D、E、F、G，后续序列为B、D、C、A、F、G、E。该二叉树对应的树林包括多少棵树：

【解析】：

![](/assets/二叉树孩子节点.png)

 第一步：还是先求root根节点，根据后序遍历规则我们可知root为后序遍历序列的最后一个节点，因此该二叉树的root节点为E。

 第二步：求root的左子树和右子树，这点我们还是从中序遍历序列中找出，位于root节点E左侧的ABCD为root的左子树，位于E右侧的FG为右子树。

 第三步：求root的左孩子leftchild和右孩子rightchild，leftchild为左子树的根节点，rightchild为右子树的根节点。我们可以找到左子树ABCD在后序遍历序列中的排列顺序为BDCA，由于后序遍历最后访问根节点，所以A为左子树的根节点，即A为root的leftchild；同理root的rightchild为G。

 第四步：我们可以根据上面的步骤找到B的左子树和右子树，以及C的左子树和右子树，然后分别求出左右子树的根节点。以此类推，只要求出根节点及其leftchild和rightchild，剩下的过程都是递归的，最后我们就可以还原整个二叉树。

           E

      A        G

       C      F

      B D

把二叉树转换到树和森林自然的方式是：若结点x是双亲y的左孩子，则把x的右孩子，右孩子的右孩子，…，都与y用连线连起来，最后去掉所有双亲到右孩子的连线。

森林中含有数的个数，就是二叉树右孩子的数目+1，这里为2

7.以下程序是用辗转相除法来计算两个非负数之间的最大公约数：

long long gcd\(long long x, long long y\) {

    if \(y == 0\)

        return x;

    else

        return gcd\(y, x % y\);

}

我们假设x,y中最大的那个数的长度为n，x&gt;y，基本运算时间复杂度为O\(1\)，那么该程序的时间复杂度为（ ）

【解析】：求最大公约数的最常用的算法是欧几里得算法,也称为辗转相除法.

问题定义为求i和j的最大公约数gcd\(i,j\),其中i和j是整数,不妨设i&gt;j.

算法可以递归的表示:

1.如果j能整除i,那么gcd\(i,j\)=j;

2.j不能整除i,令r=i%j,那么gcd\(i,j\)=gcd\(j,r\).

使用C语言实现:

int gcd\(int i, int j\)

{

    int r = i % j;

    return r == 0 ? j : gcd\(j, r\);

}

正确性分析:

算法的步骤1,显然成立\(最大公约数定义\).关键是要证明步骤2.

设d是i和j的最大公约数,

那么i=md,j=nd,m和n互质\(否则d不是最大公约数\).

由r=i%j可以得到i=kj+r,k=⌊m/n⌋,k≥1\(我们前面假设过i&gt;j\).

把i=md,j=nd代入得到

md=knd+r

那么

r=\(m-kn\)d

m-kn和m也是互质的.

所以得到d是j和r的最大公约数.

时间复杂度分析:

逆着看该算法,最后的余数是0,倒数第二次余数是d,倒数第三次是kd,k&gt;1…

由于组成了一个数列,{0,d,kd,nkd+d,…}

数列的n项加上n+1项,比n+2项要小,所以比斐波纳契数列增长的要快.

我们已知斐波纳契数列增长速度是指数,那么待分析的数列也是指数增长.

设欧几里得算法需要k次,那么j=O\(2^k\),则k=O\(lg j\).

8.Given:

public class IfTest{

    public static void main\(string\[\]args\){

        int x=3;

        int y=1;

        if\(x=y\)

            System.out.println\(“Not equal”\);

        else

            System.out.println\(“Equal”\);

     }

}

What is the result?

【解析】：其实这个是由于java和C语言的不同处理机制导致的：

C语言中

当if语句中的条件为赋值语句时，实际上是将赋值后的结果与0进行比较【左值】

if（1）  由于1&gt;0  所以认为是true

java语言中，虽然也用了左值，但是不再与0比较，而是直接将0放入if\(\)中

但是int类型，不能转换为boolean，所以会报错：“ Type mismatch: cannot convert from int to boolean ”

9.关键路径是AOE网中\(\)

从始点到终点的最短路径

从始点到终点的最长路径

从始点到终点的边数最多的路径

从始点到终点的边数最少的路径

