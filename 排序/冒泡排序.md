## 冒泡排序

---

冒泡排序的思想：两两比较相邻记录的关键码，如果反序则交换，直到没有反序的记录为止。

（1）将整个待排序的记录序列划分成有序和无需区，初始状态下有序区为空，无序区包含所有的待排序记录。

（2）对无序区从前向后依次将相邻记录关键码进行比较，若反序则交换，从而使得关键码小的记录向前移动，关键码大的向后移动。

（3）重复执行（2），直到无序区中没有反序的记录。

![](/assets/冒泡排序.png)

```
public void bubbleSort(int[] a){
    int i = a.length-1;
    while(i>0){
        //控制有序区的起点
        int pos = 0;
        for(int j =0;j<i;j++){
            if(a[j]>a[j+1]){
                pos = j;
                int temp = a[j];
                a[j] = a[j+!];
                a[j+1] = temp;
            }
        }
        i = pos;
    }
}
```

冒泡排序的执行时间取决于排序的趟数

在最好的情况下，待排序记录序列为正序，算法只执行一趟，进行n-1次比较，不需要移动记录，时间复杂度为O\(n\)

在最坏的情况下，待排序记录为反序，算法要执行n-1趟，关键码的比较次数为n\(n-1\)/2,记录的移动次数为3n\(n-1\)/2，所以时间复杂度为O\(n^2\)

平均情况下时间复杂度为O\(n^2\)

冒泡排序也只需要一个辅助空间，用来作为记录交换的暂存单元。

冒泡排序是一种稳定的排序。

