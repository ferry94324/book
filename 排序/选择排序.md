## 简单选择排序

---

### 1.基本思想

在第i趟排序时在待排序序列中选择最小的记录与第i个记录交换作为有序序列的第i个记录的过程。

### 2.实现过程

（1）将整个序列划分为有序序列和无序序列，初始有序序列为空，无序区含有待排序所有记录

（2）在无序区中选择关键码最小的一个，将它与无序区的第一个记录交换，使得无序区减少一个关键码，有序区增加一个关键码

（3）不断重复（2），直到无序区只剩一条记录为止

主要难点在于如何找到关键码最小的一个和如何确定关键码最小的位置。

### 3.具体实现

### ![](/assets/简单选择排序.png)4.算法实现

```
 public void swap(int a[],int i,int j){
        if (i==j){
            return;
        }
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
    public void SelectSort(int a[]){
        for (int i = 0;i<a.length;i++){
            int k = i;    //存放待排序记录的初始位置
            for (int j = i+1;j<a.length;j++){
                if (a[k]>a[j]){
                    k = j;//找到待排序记录中最小值的位置
                }
            }
            swap(a,k,i);//交换待排序记录中的第一个与最小值位置，并将这个放入有序区
        }
    }
```

改进：从两端同时进行选择排序

```
public void selectTwoSort(int a[]){
        for (int i =0;i<a.length;i++){
            int min = i;
            int max = a.length-i-1;
            for (int j = i+1;j<a.length-i-1;j++){
                //可找到记录的最大值和最小值
                if (a[j]<a[min]){
                    min = j;
                    continue;
                }
                if (a[j]>a[max]){
                    max = j;
                }
            }
            swap(a,min,i);
            swap(a,max,a.length-i-1);
        }
    }
```

### 5.性能分析

简单选择排序记录的移动次数较少，在待排序正序的时候，记录的移动次数最少，为0次；在待排序序列为逆序的时候，记录的移动次数最多，为3（n-1）次

时间复杂度与排序顺序无关，在最好和最坏情况下，排序的时间复杂度时O\(n^2\)

简单选择排序过程中，只需要一个用作记录交换的暂存单元

简单选择排序是一种不稳定的排序方法

