## 快速排序

---

### 1.快速排序的改进

快速排序是堆冒泡排序的一种改进，具体改进着手点在于：（1）对于冒泡排序来说，记录的比较和移动都是在相邻位置间的互相移动，这样比较和移动的次数比较多。（2）对于快速排序来说，记录的移动和比较都是在两端进行的，关键码大的就可以移动到后面，较小的移动到前面。

### 2.基本思想

首先要选出一个轴值将待排序记录分开成两个独立的部分，而且左侧的关键码小于等于轴值，右侧的关键码大于或等于轴值。然后分别对左右重复上述过程。

### 3.过程

### ![](/assets/快排.png)

### 4.算法实现

1.得到轴值将关键码分为两个区域。

```
public int getMid(int[] a,int low, int high){
    int key = a[low]; //初始化哨兵，取低位。
    while(low<high){
        while(low<high&&a[high]>key){
            high--;
        }
        a[low] = a[high];
        while(los<high&&a[low]<key){
            low++
        } 
        a[high] = a[low];
    }
    a[low] = key;
    return low;
}
```

2.实现快速排序

```
public void quickSort(int[] a,int low,int high){
    if(low<high){
        int middle = getMid(a,low,high);
        quickSort(a,low,middle-1);
        quickSort(a,middle+1,high);
    } 
}
```

### 5.性能分析

快速排序的趟数取决于递归的深度

在最好的情况下，每次划分对一个记录定位后，这个记录的左侧子序列于右侧子序列的长度相同。时间复杂度是O（nlog2n）

在最坏的情况下，待排序记录序列正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，另一个序列为空。所以时间复杂度是O\(n^2\)

平均时间复杂度是O（nlog2n）

快速排序需要用一个栈来存放每一层递归调用的必要信息，其最大容量与递归调用的深度一致，最坏，深度O（nlog2n），最好，深度为O（n），平均情况下为O（nlog2n）

快速排序是一种不稳定的排序

快速排序适合待排序记录个数很大且原始记录随机排列的情况

快速排序是所有内排序中平均性能最好的一个

