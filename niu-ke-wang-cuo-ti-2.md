## 2018-04-04

---

**1.以下代码对其执行后，NumberList里的元素依次为：**

```
List<Integer> NumberList =newArrayList<Integer>();
NumberList.add(2);
NumberList.add(4);
NumberList.add(1);
NumberList.add(3);
NumberList.add(5);
for(int i =0;i<NumberList.size();++i)
{
int v = NumberList.get(i);
if(v%2==0)
{
NumberList.remove(v);
}
}
System.out.println(NumberList);
```

【**解析**】：1.ArrayList删除元素后，剩余元素会依次向前移动，因此下标一直在变，size\(\)也会减小；

2.remove\(\)方法调用的是remove\(int index\)，而不是remove\(Object o\)，因此删除的是index索引处的元素；

该题具体流程：1.i=0,v=2,remove\(2\)删除掉了元素1，因此NumberList剩余元素为【2,4,3,5】；

2.i=1,v=4,remove\(4\),此时线性表中只有四个元素，不可能删除索引为4的元素，因此会报数组下标越界异常。

**2.对于任意一个图，从它的某个结点进行一次深度或广度优先遍历可以访问到该图的每个顶点，这样的说法正确吗？**

【**解析**】：连通图可以，非连通图不行

**3.关于抽象类叙述正确的是？ \(\)**

* 抽象类不能实现接口
* 抽象类必须有“abstract class”修饰
* 抽象类必须包含抽象方法
* 抽象类也有类的特性，可以被实例化

【**解析**】：A.抽象类是可以实现接口的，而且抽象类也可以继承自抽象类

B.对

C.抽象类指有abstract修饰的class，其可以包含抽象方法，也可以不包含

D.抽象类和接口都是不能被实例化的，只有具体的类才可以被实例化

**4.以下代码执行的结果显示是多少（ ）？**

```
public class Demo { class Super{ int flag=1;
        Super(){
            test();
        } void test(){
            System.out.println("Super.test() flag="+flag);
        }
    } class Sub extends Super
    {
        Sub(int i){ flag=i;
            System.out.println("Sub.Sub()flag="+flag);
        } void test(){
            System.out.println("Sub.test()flag="+flag);
        }
    } public static void main(String[] args) { new Demo().new Sub(5);
    }
}
```

【**解析**】：在继承中代码的执行顺序为：

1.父类静态对象，父类静态代码块

2.子类静态对象，子类静态代码块

3.父类非静态对象，父类非静态代码块

4.父类构造函数

5.子类非静态对象，子类非静态代码块

6.子类构造函数

对于本题来说：在只想new Sub\(5\)的时候，父类先初始化了 int flag = 1，然后执行父类的构造函数Super（），父类构造函数中执行的test（）方法，因子类是重写了test（）方法的，因此父类构造函数中的test（）方法实际执行的是子类的test（）方法，所以输出为Sub.test\(\) flag=1，接着执行子类构造函数Sub\(5\) 将flag赋值为5，因此输出结果Sub.Sub\(\) flag=5。最终选择了A。

**5.由3个结点可以构造出多少种不同的二叉树?\(\)**

【**解析**】：![](/assets/卡特兰数.png)![](/assets/构造二叉树.png)

**6.在有向图G的拓扑序列中,若顶点Vi 在顶点Vj 之前,则下列情形不可能出现的是\(\)**

1. **G中有弧\(Vi,Vj\)   **
2. **G中有一条从Vi到Vj的路径   **
3. **G中没有弧\(Vi,Vj\)   **
4. **G中有一条从Vj到Vi的路径**

【**解析**】：D 中，如果存在Vj到Vi的路径，那么拓扑排序Vi不可能在Vj的前面，因为还存在入度。拓扑序列：有向图中，任何顶点若满足顶点 Vi -&gt; Vj 有一条路径，则在顶点序列中顶点 Vi 必在 顶点 Vj 之前。

**7.最佳二叉搜索树是？**

1. **关键码个数最少的二叉搜索树   **
2. **搜索时平均比较次数最少的二叉搜索树   **
3. **所有结点的左子树都为空的二叉搜索树   **
4. **所有结点的右子树都为空的二叉搜索树**

【**解析**】:二叉搜索树上面的搜索相当于二分查找。所有节点的左子树或者右子树为空，则搜索退化为顺序查找，是最不理想的。二叉搜索树就是为了减少比较次数，所有平均搜索次数最少的二叉搜索树是最佳的。

最优二叉查找树：

给定n个互异的关键字组成的序列K=&lt;k1,k2,...,kn&gt;，且关键字有序（k1&lt;k2&lt;...&lt;kn），我们想从这些关键字中构造一棵二叉查找树。对每个关键字ki，一次搜索搜索到的概率为pi。可能有一些搜索的值不在K内，因此还有n+1个“虚拟键”d0,d1,...,dn，他们代表不在K内的值。具体：d0代表所有小于k1的值，dn代表所有大于kn的值。而对于i = 1,2,...,n-1,虚拟键di代表所有位于ki和ki+1之间的值。对于每个虚拟键，一次搜索对应于di的概率为qi。要使得查找一个节点的期望代价（代价可以定义为：比如从根节点到目标节点的路径上节点数目）最小，就需要建立一棵最优二叉查找树。

**8.执行下列代码的输出结果是\( \)**

```
public class Demo{
　public static void main(String args[]){
　　　int num = 10;
　　　System.out.println(test(num));
}
public static int test(int b){
　　　try
　　　{
　　　　b += 10;
　　　　return b;
　　　}
　　　catch(RuntimeException e)
　　　{
　　　}
　　　catch(Exception e2)
　　　{
　　　}
　　　finally
　　　{
　　　　b += 10;
　　　　return b;
　　　}
　　}
}
```

【**解析**】：结论一：

return语句并不是函数的最终出口，如果有finally语句，这在return之后还会执行finally（return的值会暂存在栈里面，等待finally执行后再返回）

结论二：

finally里面不建议放return语句，根据需要，return语句可以放在try和catch里面和函数的最后。可行的做法有四：

（1）return语句只在函数最后出现一次。

（2）return语句仅在try和catch里面都出现。

（3）return语句仅在try和函数的最后都出现。

（4）return语句仅在catch和函数的最后都出现。

注意，除此之外的其他做法都是不可行的，编译器会报错

**9.一个网\(带权图\)都有唯一的最小生成树\(\)**

【**解析**】：最小生成树可以有多个， 他们的权值相等且最小即可

**10.将一棵二叉树的根节点放入队列，然后将队头元素出队，将出队结点所有子节点入队，递归执行上述操作。以上操作可以实现哪种遍历？**

【**解析**】：前序，中序，后序遍历的非递归遍历利用栈。深度优先搜索通过栈来实现，而广度优先（层序遍历）搜索通过队列来实现。

**11.结构型模式中最体现扩展性的模式是（）**

【**解析**】：结构型模式是描述如何将类对象结合在一起，形成一个更大的结构，结构模式描述两种不同的东西：类与类的实例。故可以分为类结构模式和对象结构模式。

在GoF设计模式中，结构型模式有：

1.适配器模式 Adapter

  适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

  两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。

2.桥接模式 Bridge

  桥接模式将抽象部分与它的实现部分分离，是它们都可以独立地变化。它很好的支持了开闭原则和组合锯和复用原则。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这些多角度分离出来让他们独立变化，减少他们之间的耦合。

3.组合模式 Composite

  组合模式将对象组合成树形结构以表示部分-整体的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。

4.装饰模式 Decorator

装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活。也可以这样说，装饰模式把复杂类中的核心职责和装饰功能区分开了，这样既简化了复杂类，有去除了相关类中重复的装饰逻辑。 装饰模式没有通过继承原有类来扩展功能，但却达到了一样的目的，而且比继承更加灵活，所以可以说装饰模式是继承关系的一种替代方案。

5.外观模式 Facade

 外观模式为子系统中的一组接口提供了同意的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。

6.享元模式 Flyweight

 享元模式为运用共享技术有效的支持大量细粒度的对象。因为它可以通过共享大幅度地减少单个实例的数目，避免了大量非常相似类的开销。.

      享元模式是一个类别的多个对象共享这个类别的一个对象，而不是各自再实例化各自的对象。这样就达到了节省内存的目的。

7.代理模式 Proxy   

为其他对象提供一种代理，并由代理对象控制对原对象的引用，以间接控制对原对象的访问。

**12.设一个链表最常用的操作是在末尾插入结点和删除尾结点，则选用（）最节省时间。**

1. 单链表
2. 单循环链表
3. 带尾指针的单循环链表
4. 带头结点的双循环链表

【**解析**】：带尾指针的单向链表：插入可以，但是删除无法完成，因为p需要前移，但是单向链表无法得到前一个节点。

带尾指针的双向链表：插入和删除都很简单。

带尾指针的单向循环链表：插入很简单，删除则需要遍历整个链表，比较费时。

带头指针的双向循环链表：插入和删除都很简单。

重点在于避免遍历整个链表

**13.下面哪些属于算法的基本特征？**

【**解析**】：算法的5个基本特征：确定性、有穷性、输入、输出、可行性。

**14.下面有关servlet的层级结构和常用的类，说法正确的有?**

【**解析**】![](/assets/servlet.png)

HttpServlet是GenericServlet的子类。

GenericServlet是个抽象类，必须给出子类才能实例化。它给 出了设计servlet的一些骨架，定义了servlet生命周期，还有一些得到名字、配置、初始化参数的方法，其设计的是和应用层协议无关的，也就是说 你有可能用非http协议实现它。

HttpServlet是子类，当然就具有GenericServlet的一切特性，还添加了doGet, doPost, doDelete, doPut, doTrace等方法对应处理http协议里的命令的请求响应过程。

一般没有特殊需要，自己写的Servlet都扩展HttpServlet 。

**15.在Java语言中，下列关于字符集编码（Character set encoding）和国际化（i18n）的问题，哪些是正确的？**

【**解析**】：很多人都把Unicode编码挂在嘴边，其实咱们现实生活中遇到的编码基本都是Unicode的

因为Unicode兼容了大多数老版本的编码规范例如 ASCII

Unicode编码定义了这个世界上几乎所有字符（就是你眼睛看到的长那个样子的符号）的数字表示

也就是说Unicode为每个字符发了一张身份证，这张身份证上有一串唯一的数字ID确定了这个字符

在这个纷乱世界上存在的唯一性。Unicode给这串数字ID起了个名字叫**［码点］（Code Point）**

而很多人说的编码其实是想表达**［Unicode转换格式］（即UTF，Unicode Transformation Formats）**

有没有觉得眼前一亮豁然开朗？没错 这就是我们看到的UTF-8/UTF-16/UTF-32的前缀来源

这个［Unicode转换格式］的存在是为了解决［码点］在计算机中的二进制表现形式而设计的

毕竟我们的机内表示涉及存储位宽，兼容古老编码格式，码点是数值过大的罕见字符等问题

［码点］经过映射后得到的二进制串的转换格式单位称之为**［码元］（Code Unit）**。也就是说如果有一种UTF的码点二进制表示有n字节，其码元为8位（1个byte），那么其拥有码元n个。每种UTF的码元都不同，其宽度被作为区分写在了UTF的后缀——这就是UTF-8/UTF-16/UTF-32的由来。UTF-8的码元是8位的，UTF-16的码元是16位的。大部分的编程语言采用16位的码元作为机内表示。这就是我们在各种语言中调用获取一个字符串中character的数量时会出现这么多混乱的原因。事实上我们调用这些方法时取得的不是字符个数，而是**码元个数**！一旦我们的字符串中包含了位于基本平面之外的码点，那么就会需要更多的码元来表示，这个时候就会出现测试时常见的困惑——为何return的字符数比实际字符数要多？所以实际写代码时要特别注意这个问题。

采取不同的映射方式可以得到不同格式的二进制串，但是他们背后所表示的［码点］永远是一致的就好像你换身份证但是身份证号不变一样。由于平时人们误把［转换格式］也称为［编码］，所以造成今天Unicode／UTF傻傻分不清楚且遣词造句运用混乱的悲桑局面。

Unicode 编码 发展到今天 扩展到了 21 位（从 U+0000 到 U+10FFFF ）。这一点很重要：**Unicode不是16位的编码，**它是 21 位的。这 21 位提供了 1,114,112 个码点，其中，只有大概 10% 正在使用，所以还有相当大的扩充空间。

编码空间被分成 17 个**平面**（plane），每个平面有 65,536 个字符（正好填充2个字节，16位）。0 号平面叫做**「基本多文种平面」（BMP,Basic Multilingual Plane）**，涵盖了几乎所有你能遇到的字符，除了 emoji（emoji位于1号平面 - -）。其它平面叫做补充平面，大多是空的。

总结一下各种编码格式的特质：

**UTF-32**

最清楚明了的一个 UTF 就是 UTF[-](http://en.wikipedia.org/wiki/UTF-32)32 ：它在每个码点上使用整 32 位。32 大于 21，因此每一个 UTF-32 值都可以直接表示对应的码点。尽管简单，UTF-32却几乎从来不在实际中使用，因为每个字符占用 4 字节太浪费空间了。

**UTF-16以及「代理对」（Surrogate Pairs）的概念**

UTF[-](http://en.wikipedia.org/wiki/UTF-16)16要常见得多，它是根据有 16 位固定长度的**码元（code units）**定义的。UTF-16 本身是一种长度可变的编码。基本多文种平面（BMP）中的每一个码点都直接与一个码元相映射。鉴于 BMP 几乎囊括了所有常见字符，UTF-16 一般只需要 UTF-32 一半的空间。其它平面里很少使用的码点都是用两个 16 位的码元来编码的，这两个合起来表示一个码点的码元就叫做**代理对（surrogate pair）**。

**UTF-8**

UTF-8 使用一到四个字节来编码一个码点。从 0 到 127 的这些码点直接映射成 1 个字节（对于只包含这个范围字符的文本来说，这一点使得 UTF-8 和 ASCII 完全相同）。接下来的 1,920 个码点映射成 2 个字节，在 BMP 里所有剩下的码点需要 3 个字节。Unicode 的其他平面里的码点则需要 4 个字节。UTF-8 是基于 8 位的码元的，因此它并不需要关心字节顺序（不过仍有一些程序会在 UTF-8 文件里加上多余的 BOM）。

有效率的空间使用（仅就西方语言来讲），以及不需要操心字节顺序问题使得 UTF-8 成为存储和交流 Unicode 文本方面的最佳编码。它也已经是文件格式、网络协议以及 Web API 领域里**事实上**的标准了。

我们的JVM中保存码点是UTF16的转换格式，从char的位宽为16位也可以看得出来。由于绝大部分编码的码点位于基本平面，所以使用16位可以几乎表示所有常用字符。这就是许多语言编译器或运行时都使用UTF16的原因。英文在使用UTF16时也是2字节表示的。当我们想要使用其他平面的字符时，码元超过2个字节，就需要使用代理对在语言中的特定表示方式，譬如‘\U112233’之类的。

使用UTF8时，常用的Alphabet和Numeric都在前127字节，被有效率地用一个字节表示。而我们的中文由于排在1920个码点之后，所以使用3个字节表示，这方面就比UTF16转换格式耗费更多空间。

最后，不论使用哪种UTF转换格式，都是程序员自己可以选择的一种表达方式而已。我们可以通过Java方便的API进行自如转换。

