## 2018-4-9

---

**1.完全二叉树肯定是平衡二叉树。（）**

【**解析**】：从平衡因子定义看，完全二叉树任一结点的平衡因子的绝对值确实是小于等于1。但是，平衡二叉树本质上是二叉排序树，完全二叉树不一定是排序树。故不能说完全二叉树是平衡二叉树。

平衡二叉树是一种特殊的二叉排序树，但是二叉排序树并不一定是完全二叉树。

**2.若树 T 有 a 个度为 1 的结点， b 个度为 2 的结点， c 个度为 3 的结点，则该树有 个叶结点。**

【**解析**】：节点数 = 分叉树 + 1

解：设该树拥有叶子节点数为y.

a + b + c + y = a\*1 + 2\*b + 3\*c + 1

得到： y = b + 2c +1

**3.若一组记录的排序码为（46, 79, 56, 38, 40, 84），则利用快速排序，以第一个记录为基准得到的一次划分结果是 （）**

【**解析**】：![](/assets/快速排序.png)**4.类Parent和Child定义如下：**

```
1 ．class  Parent{
2.         public  float  aFun(float a, float b) { }
3 ．}
4 ．class  Child  extends  Parent{
5 ．
6 ．}
```

**将以下哪种方法插入行5是不合法的。（    ）**

* \*\*float aFun\(float  a,  float  b\){ }
  \*\*
* \*\*public int aFun\(int a, int b\) { }
  \*\*
* \*\*public float aFun\(float  p,  float q\){ }
  \*\*
* **private int aFun\(int a,  int  b\){ }**

【**解析**】：方法重写应遵循“三同一小一大”原则：

“三同”：即方法名相同，形参列表相同，返回值类型相同；

“一小”：子类方法声明抛出的异常比父类方法声明抛出的异常更小或者相等；

“一大”:子类方法的访问修饰符应比父类方法更大或相等。

A选项是重写，但是默认访问修饰符比父类小，插入第五行编辑器会报错。

B、D不是重写。因为形参列表和返回值类型不同，不满足“三同”。所以写在第五行以普通方法对待，插入第五行没有错误。

C选项满足重写的各项条件，是正确的重写，所以插入第五行没有错误

**5.有时为了避免某些未识别的异常抛给更高的上层应用，在某些接口实现中我们通常需要捕获编译运行期所有的异常， catch 下述哪个类的实例才能达到目的：（）**

* \*\*Error
  \*\*
* \*\*Exception
  \*\*
* \*\*RuntimeException
  \*\*
* **Throwable**

【**解析**】：因为error是系统出错，catch是无法处理的，难以修复的，RuntimeException不需要程序员进行捕获处理，error和exception都是throwable的子类，我们只需要对exception的实例进行捕获即可

**6.请读程序：**

```
#include
int main() {
    int a, b;
    for (a = 1, b = 1; a <= 100; a++) { if (b >= 20)
            break;
        if (b % 3 == 1) {
            b += 3;
            continue;
        }
        b -= 5;
    }
    printf("%d\n", a);
    return 0;
}
```

**上面的输出结果为\(\)**

【**解析**】：设循环次数为n,则因为b&lt;=20;b+=3;  
令1+3\*n&gt;=20,n为整数取7，a每次循环增1所以a=1+7\*1=8

输出a的值是在for之后，所以我们要先分析程序跳出for的情况。由代码可知，程序跳出for循环的情况有两种：

b大于或等于20，执行break语句，跳出for循环；

a大于100，不满足循环条件，跳出循环；

如果是第二种情况的话，显然a等于101，ABCD都不是，所以程序是第一种情况跳出for。接下来就是分析在第一种情况下跳出for后，a的值。我们知道在第一种情况下，b最后的值肯定是大于20，所以前面所有b的值都应该在20以内，且都是模3余1的被除数，因为b初值为1，模3余1，接下来又每次都加3，所以按顺序应该是1,4,7,10,13,16,19。最后b+=3,b=21，跳出循环，此时a=8。

执行代码，结果“8”。

**7.下面哪个不是标准Statement类？**

* \*\*Statement
  \*\*
* \*\*PreparedStatement
  \*\*
* \*\*CallableStatement
  \*\*
* **BatchedStatement**

【**解析**】：Statement在JDBC中相当于SQL语句的载体

A，Statement是最基本的用法，采用字符串拼接的方式，存在注入漏洞

B，PreparedStatement对Statement中的SQL语句进行预编译，同时检查合法性，效率高

C，CallableStatement接口扩展 PreparedStatement，用来调用存储过程,它提供了对输出和输入/输出参数的支持。CallableStatement 接口还具有对 PreparedStatement 接口提供的输入参数的支持。

D，不是标准的Statement类

**8.所谓赋权无向图G的最小生成树T,就是将G中各结点间的最短路径作为边而构造出的G的子图\(\)**

【**解析**】：错。最小生成树算法是逐次取最短的路径连通未连接节点和“已连接节点集合”。

**9.下列AOE 网表示一项包含 8 个活动的工程。通过同时加快若干活动的进度可以缩短整个工程的工期。下列选项中，加快其进度就可以缩短工程工期的是（ ）。**

![](/assets/AOE网.png)

【**解析**】：这个网有三条关键路径：

b、d、c、g

b、d、e、h

b、f、h

缩短工期的活动要涵盖三条路径。

acg-18

aeh-18

bdcg-27

bdeh-27

bfh-27

所以只有f和d才能同时缩短三条长度为27的路径。

**10.设有n个关键字具有相同的Hash函数值，则用线性探测法把这n个关键字映射到Hash表中需要做几次线性探测？**

【**解析**】：第一个关键字直接插入，第二个关键字要做1次探测，所以类推n个关键词要做0+1+2+...+\(n-1\) = n\*\(n-1\) / 2

**11.在图采用邻接表存储时,求最小生成树的Prim算法的时间复杂度为\(\)**

【**解析**】：邻接表是O（n+e），邻接矩阵存储是O（n^2）

**12.\(1\). 求从指定源点到其余各顶点的迪杰斯特拉（Dijkstra）最短路径算法中弧上权不能为负的原因是在实际应用中无意义；  
**

**\(2\). 利用Dijkstra求每一对不同顶点之间的最短路径的算法时间是O\(n3 \) ；（图用邻接矩阵表示）  
**

**\(3\). Floyd 求每对不同顶点对的算法中允许弧上的权为负，但不能有权和为负的回路。  
**

**上面不正确的是（ ）。**

【**解析**】：Floyd 可以有负权边是因为它依靠的动态规划，比如a-b权值为1,而a-c权值2,c-b权值为-3，那么根据算法a-b最短路径为-1.Dij算法不能有负权边的原因是它依靠贪心算法，a-b最短路径就为1,实际上是-1

Floyd 不能有负权回路，这个容易理解，a-b，b-c，c-a权值分别为1，-2，-3，那么一直这样回路下去a-b-c-a会一直小，显然算法要在这儿停下，不然就没最短路径这一说。

所以1错，3对。

2的说法用dijkstra算法求两点间，并且是邻接矩阵存储时的时间复杂度是n平方级别的，n个点两两之间的是n立方级别的，是对的。

**13.java中Hashtable, Vector, TreeSet, LinkedList哪些线程是安全的？**

【**解析**】：HashMap是线程安全的HashMap

Vector是线程安全的ArrayList

TreeSet和LinkedList都不是线程安全的

线程安全概念：

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。

线程安全问题都是由全局变量及静态变量引起的。

若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

LinkedList 和 ArrayList 都是不同步的，线程不安全；

Vector 和 Stack 都是同步的，线程安全；

Set是线程不安全的；

Hashtable的方法是同步的，线程安全；

HashMap的方法不是同步的，线程不安全；

**14.在 hibernate 开发中，关于 POJO 类对象的状态说法正确的是（）。**

【**解析**】：Session的update\(\) ,saveOrUpdate\(\)和lock\(\)方法使游离状态变为持久化状态.

持久化对象的特征:

. 位于一个session事例的缓存中,可以说持久化对象总是被一个session事例关联

. 持久化对象和数据库中的相关记录对应

. Session在清理缓存时,会根据持久化对象的属性变化来同步更新数据库

. Session的save\(\)方法把临时状态变为持久化状态.

Session的update\(\) ,saveOrUpdate\(\)和lock\(\)方法使游离状态变为持久化状态.

**15.2-3树是一种特殊的树，它满足两个条件：   
**

**（1）每个内部节点有两个或三个子节点；   
**

**（2）所有的叶节点到根的路径长度相同；  
**

**如果一颗2-3树有9个叶节点，2-3树中非叶节点的个数可能是**

【**解析**】：根据条件\(2\)，叶节点只能在同一层，根据条件\(1\)，上一层的父节点只能是3个或4个，只能是如下图所示的两种结果

![](/assets/2-3树1.png)![](/assets/2-3树2.png)

**16.以下哪个选项中可能应用到栈。**

* **递归**
* **快速排序（非递归程序用栈实现）**
* **表达式求值**
* **树的遍历**

【**解析**】：A，递归肯定用到栈的，存放局部变量，返回地址等，不过该栈是操作系统提供的栈。

B，快速排序的非递归实现，栈中存放要进行一遍快排的起始位置，利用栈先进后出的方式，模拟递归的过程。

C，表达式求值，将中序表达式转换为前序或后序时，需要用栈存放符号。

D，树的深度优先遍历，用栈记录遍历过的元素，以便进行回溯

**17.算法一般都可以用哪几种控制结构组合而成？**

* **顺序  **
* **选择  **
* **递归  **
* **循环**

【**解析**】：算法的基本控制结构： 顺序、选择、循环。递归不属于基本控制结构

