## 2018-4-8

---

**1.关于顺序表叙述，正确的是（）**

【**解析**】：

**2.图G的拓扑序列唯一，则其弧数必为n-1\(其中n为G的顶点数\)**

【**解析**】：有向图的邻接矩阵上三角全为1即可达到拓扑唯一，那么边数为n\(n-1\)/2

**3.在所有的排序方法中，关键字比较的次数与记录的初始排列次序无关的是 。**

* **希尔排序**
* **冒泡排序**
* **直接插入排序**
* **直接选择排序**

【**解析**】：选择排序，特点是：排序总是从第一位开始，与起始位无关；

插入排序，是把待排序的元素 L\(i\) 取出，放到辅助空间 S 中，（s为我定义的名字，可以为其他任何名字），然后 S（即L\(i\)） 依次与 L（--i） 比较，满足插入条件，就直接插入到当前位置，不再跟下面的元素比较；它显然能很快找到离 i 位置最近的插入点（该插入点离i很接近，即题中说的情况）；

快速排序，在数据基本无序的情况下最快

**4.  
以下排序方式中占用O（n）辅助存储空间的是**

* **简单排序**
* **快速排序**
* **堆排序**
* **归并排序**

【**解析**】：归并排序在归并过程中需要与原始序列相等的存储空间O（n）用于存放归并结果：

递归实现的归并排序还需考虑深度为log2n的栈空间，因此空间复杂度为O（n+log2n）;

而非递归实现的归并排序避免了递归时深度为log2n的栈空间，因此空间复杂度为O（n）。

归并排序是所有排序中占用内存最多，但是效率比较高且稳定的算法，即牺牲内存提高了效率

**5.快速排序在下列哪种情况下最易发挥其长处？**

* **被排序的数据已基本有序**
* **被排序的数据中含有多个相同排序码**
* **被排序的数据完全无序**
* **被排序的数据中的最大值和最小值相差悬殊**

【**解析**】：c 当初始序列整体或局部有序时，快速排序性能下降，将退化为冒泡排序。基本有序的时候选择插入排序

**6.有ABCDEF 六个城市，每一个城市都和其他所有城市直接相连，问从A——B有多少种连接方式，路径不允许在两个城市之间往返？**

【**解析**】：A-B:1

A-?-B:4

A-?-?-B:4\*3

A-?-?-?-B:4\*3\*2

A-?-?-?-?-B:4\*3\*2\*1

**7.某一系统功能,需要一次性加载N\(N在1000左右\)个随机数,后续只对该集合进行遍历.最宜采用哪种结构存放？**

【**解析**】：随机数，未经排序，二叉树不适合；

需要遍历，hash表不适合；

不强调数据之间的关系，图不适合；

随机数数据类型不一致，数组不适合。

综上所述，链表最适合。

首先说了 需要一次性加载N\(N在1000左右\) 个随机数。 随机数可能是用byte，char，short,int long float,double存储;最乐观的是byte存储才占一个字节长度 1000个约占用内存 1KB； 最悲观的是用 long 或double \(8字节\) ，以C语言为例 ：long double（多精度浮点类型或长精度浮点类型）不同平台有不同的实现。有的是8字节，有的是10字节，有的是12字节或16字节 咱们用16字节来算 也才16\*1000=16KB 内存也很少。

再来说说数据结构：

数组：连续存储，遍历快且方便，长度固定，缺点移除和添加 需要迁移n个数据或者后移n个数据

链表：离散存储，添加删除方便，空间和时间消耗大，双向链表比单向的更灵活，但是空间耗费也更大

Hash表：数据离散存储，利用hash算法决定存储位置，遍历麻烦。以java的HashMap为例

二叉树：一般的查找遍历，有深度优先和广度优先，遍历分前序、中序、后序遍历，效率都差不多，但是如果数据经过排序，二叉树效率还是不错。

图：表示物件与物件之间的关系的数学对象，常用遍历方式深度优先遍历和广度优先遍历，这两种遍历方式对有向图和无向图均适用，遍历查找不及前面人一种数据结构

**8.若线性表最常用的操作是存取第n个元素及其前驱和后继元素的值,为节省时间应采用的存储方式\(\)**

【**解析**】：单链表只有一个指针域，是指向直接后继的。没有指向直接前驱。

循环链表也是只指向直接后继。

只有双向链表有两个指针域，分别指向直接前驱和后继。要存取值得修改两个指针

顺序表是在计算机内存中以数组的形式保存的线性表。它是数组，不用考虑修改指针，只用修改下标

**9.下面代码将输出什么内容：（）**

```
public class SystemUtil{
    public static boolean isAdmin(String userId){
        return userId.toLowerCase()=="admin";
    }
    public static void main(String[] args){
        System.out.println(isAdmin("Admin"));
    }
}
```

【**解析**】：equals和==的区别 ==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。所以是false

**10.现有1G数据需要排序，计算资源只有1G内存可用，下列排序方法中最可能出现性能问题的是\_\_\_\_。**

【**解析**】：![](/assets/排序空间复杂度.png)这道题主要是考察各种排序方法的空间复杂度

快速排序的空间复杂度为O\(logn\);归并排序的空间复杂度为O\(n\)；

其他选项的空间复杂度均为O\(1\)

**11.字符串′ababaabab′的nextval为\(\)**

【**解析**】：** i   **   0    1    2    3    4    5    6    7    8

**                    s     **a    b    a    b    a    a    b    a    b

```
       next\[i\]  -1    0    0    1    2    3    1    2    3
```

先计算前缀next\[i\]的值：

next\[i\]的值主要是看s\[i\]之前的字符串中重复的子串长度。next\[0\] = -1，定值。

next\[1\]是看s\[1\]之前的字符串“a”中重复的子串长度为0，故next\[1\] = 0。

next\[2\]是看s\[2\]之前的字符串“ab”中重复的子串长度为0，故next\[2\] = 0。

next\[3\]是看s\[3\]之前的字符串"aba"中重复的子串长度，s\[0\]与s\[2\]重复，长度为1，故next\[3\] = 1。

next\[4\]是看s\[4\]之前的字符串"abab"中重复的子串长度，s\[01\]与s\[23\]重复，长度为2，故next\[4\] = 2。

next\[5\]是看s\[5\]之前的字符串"ababa"中重复的子串长度，s\[012\]与s\[234\]重复，长度为3，故next\[5\] = 3。

next\[6\]是看s\[6\]之前的字符串"ababaa"中重复的子串长度，

**s\[0\]与s\[5\]重复\(因为多了一个a，无法找到长度为3的重复字符串，这只能是s\[0\]和s\[5\]重复\)**，长度为1，故next\[6\] = 1。

同样的，求next\[7\]和next\[8\]分别为2和3。

接下来计算nextval\[i\]的值：

nextval\[i\]的求解需要比较s中next\[i\]所在位置的字符是否与s\[i\]的字符一致，如果一致则用s\[next\[i\]\]的nextval的值作为nextval\[i\]，如果不一致，则用next\[i\]做为nextval\[i\]。

nextval\[0\] = -1,和next\[0\]的值一样。

nextval\[1\]，比较s\[next\[1\]\] ?= s\[1\]，next\[1\] = 0，s\[0\] = a，而s\[1\] = b，二者不一致，则nextval\[1\] = next\[1\] = 0。

nextval\[2\]，比较s\[next\[2\]\] ?= s\[2\]，next\[2\] = 0，s\[0\] = a，而s\[2\] = a，二者一致，则nextval\[2\] = nextval\[s\[next\[2\]\]\] = nextval\[s\[0\]\] = -1

**\(严谨来看这么表述是有问题的，因为nextval\[2\]表示nextval数组中第3个数值，而nextval\[s\[0\]\]表示的是s\[0\]对应的字母‘a’所对应的nextval值 -1，这里nextval\[\]的用法并不严谨，只是为了表述方便\)**。

nextval\[3\]，比较s\[next\[3\]\] ?= s\[3\]，next\[3\] = 1，s\[1\] = b，而s\[3\] = b，二者一致，则nextval\[3\] = nextval\[s\[next\[3\]\]\] = nextval\[s\[1\]\] = 0。

nextval\[4\]，比较s\[next\[4\]\] ?= s\[4\]，next\[4\] = 2，s\[2\] = a，而s\[4\] = a，二者一致，则nextval\[4\] = nextval\[s\[next\[4\]\]\] = nextval\[s\[2\]\] = -1。

nextval\[5\]，比较s\[next\[5\]\] ?= s\[5\]，next\[5\] = 3，s\[3\] = b，而s\[5\] = a，二者不一致，则nextval\[5\] = next\[5\] = 3。

同样的求nextval\[6\]，nextval\[7\]，nextval\[8\]分别为 0 ，-1 ， 0。

这里是nextval的下标从-1开始，如果从1开始，则其余各位均＋1，nextval为0,1,0,1,0,4,1,0,1

**12.有以下类定义：**

```
abstract class Animal{
    abstract void say();
}
public class Cat extends Animal{
    public Cat(){
        System.out.printf("I am a cat");
    }
    public static void main(String[] args) {
        Cat cat=new Cat();
    }
}
```

* **I am a cat**
* **Animal能编译，Cat不能编译**
* **Animal不能编译，Cat能编译**
* **编译能通过，但是没有输出结果**

【**解析**】：包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：

1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。

2）抽象类不能用来创建对象；

3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。

在其他方面，抽象类和普通的类并没有区别。

**13.下列哪一种叙述是正确的（ ）**

* **abstract修饰符可修饰字段、方法和类**
* **抽象方法的body部分必须用一对大括号{ }包住**
* **声明抽象方法，大括号可有可无**
* **声明抽象方法不可写出大括号**

【**解析**】：选d，abstract修饰符用来修饰类和成员方法

1：用abstract修饰的类表示抽象类，抽象类位于继承树的抽象层，抽象类不能被实例化。

2：用abstract修饰的方法表示抽象方法,抽象方法没有方法体。抽象方法用来描述系统具有什么功能，但不提供具体的实现。

Abstract是Java中的一个重要关键字，可以用来修饰一个类或者一个方法。 修饰一个方法时，表示该方法只有特征签名（signature），没有具体实现，而是把具体实现留给继承该类的子类。一个类中只要有一个abstract 方法，那么这个类就要被声明为abstract，但是其中可以有非abstract方法。 abstract类可以使得类的设计者能够创建方法的原型，而真正的实现留给使用这个类的人。

**14.关于依赖注入，下列选项中说法错误的是（）**

* **依赖注入能够独立开发各组件，然后根据组件间关系进行组装**
* **依赖注入使组件之间相互依赖，相互制约**
* **依赖注入提供使用接口编程**
* **依赖注入指对象在使用时动态注入**

【**解析**】：依赖注入和控制反转是同一概念：

依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。依赖注入是从应用程序的角度在描述，可以把依赖注入描述完整点：应用程序依赖容器创建并注入它所需要的外部资源；而控制反转是从容器的角度在描述，描述完整点：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。

**15.变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF;变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。则a+b的结果用10进制表示为多少？**

【**解析**】：（1）a+b的16进制表示为：OxFFFFFFFFFFFFFFF（16位F），转为2进制为111……111（64位1，每个F-&gt;4位2）。

（2）有符号数：是针对二进制来讲的。用最高位作为符号位，“0”代表“+”，“1”代表“-”。所以a+b的结果是一个负数。

（3）计算机中负数是以补码的形式保存的，将补码转换成原码的计算方式如下：

①. 对于正数，原码与补码相同。

②.对于负数，将补码除符号位之外，按位取反，末位加1，即得到原码。

（4）a + b = 111……111（64位1）

  取反：100……000（1位1，后面63位0）

  加一：100……00（中间62位0）

10进制：-1。

