## 2018-4-8

---

**1.关于顺序表叙述，正确的是（）**

【**解析**】：

**2.图G的拓扑序列唯一，则其弧数必为n-1\(其中n为G的顶点数\)**

【**解析**】：有向图的邻接矩阵上三角全为1即可达到拓扑唯一，那么边数为n\(n-1\)/2

**3.在所有的排序方法中，关键字比较的次数与记录的初始排列次序无关的是 。**

* **希尔排序**
* **冒泡排序**
* **直接插入排序**
* **直接选择排序**

【**解析**】：选择排序，特点是：排序总是从第一位开始，与起始位无关；

插入排序，是把待排序的元素 L\(i\) 取出，放到辅助空间 S 中，（s为我定义的名字，可以为其他任何名字），然后 S（即L\(i\)） 依次与 L（--i） 比较，满足插入条件，就直接插入到当前位置，不再跟下面的元素比较；它显然能很快找到离 i 位置最近的插入点（该插入点离i很接近，即题中说的情况）；

快速排序，在数据基本无序的情况下最快

**4.  
以下排序方式中占用O（n）辅助存储空间的是**

* **简单排序**
* **快速排序**
* **堆排序**
* **归并排序**

【**解析**】：归并排序在归并过程中需要与原始序列相等的存储空间O（n）用于存放归并结果：

递归实现的归并排序还需考虑深度为log2n的栈空间，因此空间复杂度为O（n+log2n）;

而非递归实现的归并排序避免了递归时深度为log2n的栈空间，因此空间复杂度为O（n）。

归并排序是所有排序中占用内存最多，但是效率比较高且稳定的算法，即牺牲内存提高了效率

**5.快速排序在下列哪种情况下最易发挥其长处？**

* **被排序的数据已基本有序**
* **被排序的数据中含有多个相同排序码**
* **被排序的数据完全无序**
* **被排序的数据中的最大值和最小值相差悬殊**

【**解析**】：c 当初始序列整体或局部有序时，快速排序性能下降，将退化为冒泡排序。基本有序的时候选择插入排序

**6.有ABCDEF 六个城市，每一个城市都和其他所有城市直接相连，问从A——B有多少种连接方式，路径不允许在两个城市之间往返？**

【**解析**】：A-B:1

A-?-B:4

A-?-?-B:4\*3

A-?-?-?-B:4\*3\*2

A-?-?-?-?-B:4\*3\*2\*1

**7.某一系统功能,需要一次性加载N\(N在1000左右\)个随机数,后续只对该集合进行遍历.最宜采用哪种结构存放？**

【**解析**】：随机数，未经排序，二叉树不适合；

需要遍历，hash表不适合；

不强调数据之间的关系，图不适合；

随机数数据类型不一致，数组不适合。

综上所述，链表最适合。

首先说了 需要一次性加载N\(N在1000左右\) 个随机数。 随机数可能是用byte，char，short,int long float,double存储;最乐观的是byte存储才占一个字节长度 1000个约占用内存 1KB； 最悲观的是用 long 或double \(8字节\) ，以C语言为例 ：long double（多精度浮点类型或长精度浮点类型）不同平台有不同的实现。有的是8字节，有的是10字节，有的是12字节或16字节 咱们用16字节来算 也才16\*1000=16KB 内存也很少。

再来说说数据结构：

数组：连续存储，遍历快且方便，长度固定，缺点移除和添加 需要迁移n个数据或者后移n个数据

链表：离散存储，添加删除方便，空间和时间消耗大，双向链表比单向的更灵活，但是空间耗费也更大

Hash表：数据离散存储，利用hash算法决定存储位置，遍历麻烦。以java的HashMap为例

二叉树：一般的查找遍历，有深度优先和广度优先，遍历分前序、中序、后序遍历，效率都差不多，但是如果数据经过排序，二叉树效率还是不错。

图：表示物件与物件之间的关系的数学对象，常用遍历方式深度优先遍历和广度优先遍历，这两种遍历方式对有向图和无向图均适用，遍历查找不及前面人一种数据结构

**8.若线性表最常用的操作是存取第n个元素及其前驱和后继元素的值,为节省时间应采用的存储方式\(\)**

【**解析**】：单链表只有一个指针域，是指向直接后继的。没有指向直接前驱。

循环链表也是只指向直接后继。

只有双向链表有两个指针域，分别指向直接前驱和后继。要存取值得修改两个指针

顺序表是在计算机内存中以数组的形式保存的线性表。它是数组，不用考虑修改指针，只用修改下标

**9.下面代码将输出什么内容：（）**

```
public class SystemUtil{
    public static boolean isAdmin(String userId){
        return userId.toLowerCase()=="admin";
    }
    public static void main(String[] args){
        System.out.println(isAdmin("Admin"));
    }
}
```

【**解析**】：equals和==的区别 ==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。所以是false

**10.现有1G数据需要排序，计算资源只有1G内存可用，下列排序方法中最可能出现性能问题的是\_\_\_\_。**

【**解析**】：![](/assets/排序空间复杂度.png)这道题主要是考察各种排序方法的空间复杂度

快速排序的空间复杂度为O\(logn\);归并排序的空间复杂度为O\(n\)；

其他选项的空间复杂度均为O\(1\)

**11.字符串′ababaabab′的nextval为\(\)**

【**解析**】：** i   **   0    1    2    3    4    5    6    7    8

**                    s     **a    b    a    b    a    a    b    a    b

           next\[i\]  -1    0    0    1    2    3    1    2    3

先计算前缀next\[i\]的值：

next\[i\]的值主要是看s\[i\]之前的字符串中重复的子串长度。next\[0\] = -1，定值。

next\[1\]是看s\[1\]之前的字符串“a”中重复的子串长度为0，故next\[1\] = 0。

next\[2\]是看s\[2\]之前的字符串“ab”中重复的子串长度为0，故next\[2\] = 0。

next\[3\]是看s\[3\]之前的字符串"aba"中重复的子串长度，s\[0\]与s\[2\]重复，长度为1，故next\[3\] = 1。

next\[4\]是看s\[4\]之前的字符串"abab"中重复的子串长度，s\[01\]与s\[23\]重复，长度为2，故next\[4\] = 2。

next\[5\]是看s\[5\]之前的字符串"ababa"中重复的子串长度，s\[012\]与s\[234\]重复，长度为3，故next\[5\] = 3。

next\[6\]是看s\[6\]之前的字符串"ababaa"中重复的子串长度，

**s\[0\]与s\[5\]重复\(因为多了一个a，无法找到长度为3的重复字符串，这只能是s\[0\]和s\[5\]重复\)**，长度为1，故next\[6\] = 1。

同样的，求next\[7\]和next\[8\]分别为2和3。

接下来计算nextval\[i\]的值：

nextval\[i\]的求解需要比较s中next\[i\]所在位置的字符是否与s\[i\]的字符一致，如果一致则用s\[next\[i\]\]的nextval的值作为nextval\[i\]，如果不一致，则用next\[i\]做为nextval\[i\]。

nextval\[0\] = -1,和next\[0\]的值一样。

nextval\[1\]，比较s\[next\[1\]\] ?= s\[1\]，next\[1\] = 0，s\[0\] = a，而s\[1\] = b，二者不一致，则nextval\[1\] = next\[1\] = 0。

nextval\[2\]，比较s\[next\[2\]\] ?= s\[2\]，next\[2\] = 0，s\[0\] = a，而s\[2\] = a，二者一致，则nextval\[2\] = nextval\[s\[next\[2\]\]\] = nextval\[s\[0\]\] = -1

**\(严谨来看这么表述是有问题的，因为nextval\[2\]表示nextval数组中第3个数值，而nextval\[s\[0\]\]表示的是s\[0\]对应的字母‘a’所对应的nextval值 -1，这里nextval\[\]的用法并不严谨，只是为了表述方便\)**。

nextval\[3\]，比较s\[next\[3\]\] ?= s\[3\]，next\[3\] = 1，s\[1\] = b，而s\[3\] = b，二者一致，则nextval\[3\] = nextval\[s\[next\[3\]\]\] = nextval\[s\[1\]\] = 0。

nextval\[4\]，比较s\[next\[4\]\] ?= s\[4\]，next\[4\] = 2，s\[2\] = a，而s\[4\] = a，二者一致，则nextval\[4\] = nextval\[s\[next\[4\]\]\] = nextval\[s\[2\]\] = -1。

nextval\[5\]，比较s\[next\[5\]\] ?= s\[5\]，next\[5\] = 3，s\[3\] = b，而s\[5\] = a，二者不一致，则nextval\[5\] = next\[5\] = 3。

同样的求nextval\[6\]，nextval\[7\]，nextval\[8\]分别为 0 ，-1 ， 0。

这里是nextval的下标从-1开始，如果从1开始，则其余各位均＋1，nextval为0,1,0,1,0,4,1,0,1

